// Generated by CoffeeScript 1.3.3
(function() {
  var ConnectionPool, ConnectionPromise, Driver, ResultPromise, drivers, events, genericPool, inspect;

  genericPool = require('generic-pool');

  events = require('events');

  inspect = require('util').inspect;

  exports.READ_UNCOMMITTED = 0;

  exports.READ_COMMITTED = 1;

  exports.REPEATABLE_READ = 2;

  exports.SERIALIZABLE = 3;

  /**
  * Main interface used to interact with database drivers.
  *
  * @param wrapper Wrapper to the real database driver.
  *
  */


  Driver = (function() {

    function Driver(_wrapper) {
      this._wrapper = _wrapper;
    }

    /**
    * Starts connecting to the database and returns a promise for the
    * connection.
    *
    * @param {String} connectionString Connection string used to resolve the
    * database.
    * @return {ConnectionPromise} Object that can be used to interact with the
    * database.
    *
    */


    Driver.prototype.connect = function(connectionString) {
      var closer, resolver,
        _this = this;
      resolver = new events.EventEmitter();
      this._wrapper.connect(connectionString, function(err, innerConnection) {
        return resolver.emit('resolve', err, innerConnection);
      });
      closer = function(connection) {
        return wrapper.close(connection);
      };
      return new ConnectionPromise(this._wrapper, resolver, closer, closer);
    };

    /**
    * Creates a pool to manage connections with the database.
    *
    * @param {String} connectionString Connection string used to resolve the
    * database.
    * @param {Number} max Maximum number of concurrent connections to the 
    * database.
    * @param {Number} timeout Maximum number of milliseconds a connection can be
    * idle before it is closed.
    * @return {ConnectionPool} Pool to manage connections to the database.
    *
    */


    Driver.prototype.createPool = function(connectionString, max, timeout) {
      return new ConnectionPool(this._wrapper, connectionString, max, timeout);
    };

    return Driver;

  })();

  /**
  * Represents a future connection which can be normally interacted with. All
  * statements executed on this object will be sent to the 'real' connection as
  * soon as it is available.
  *
  * @param wrapper The real driver wrapper object.
  * @param resolver EventEmitter that will emit a 'resolve' event when the 
  * connection is ready.
  * @param {Function} releaser Will be called with the real connection to signal
  * that the connection will no longer be used.
  *
  */


  ConnectionPromise = (function() {

    function ConnectionPromise(_wrapper, resolver, _releaser, _closer) {
      var _this = this;
      this._wrapper = _wrapper;
      this._releaser = _releaser;
      this._closer = _closer;
      this._queue = [];
      this._connection = null;
      this._error = null;
      this._released = false;
      this._pendingStmt = null;
      this._readyCallback = null;
      this._readyHandled = false;
      this._errorCallback = null;
      this._errorHandled = false;
      this.inTransaction = false;
      resolver.once('resolve', function(err, conn) {
        if (err) {
          _this._error = err;
        } else {
          _this._connection = conn;
          if (_this._pendingStmt === null && _this._queue[0]) {
            _this._run(_this._queue.shift());
          }
        }
        return _this._callbacks();
      });
    }

    ConnectionPromise.prototype._checkState = function() {
      var msg, reason;
      if (this._released) {
        if (this._error !== null) {
          if (typeof this._wrapper.getErrorMsg === 'function') {
            reason = this._wrapper.getErrorMsg(this._error);
          } else {
            reason = this._error.toString();
          }
          msg = "Connection is broken due to an error: " + reason;
        } else {
          msg = 'Connection is no longer available';
        }
        throw new Error(msg);
      } else if (this._error) {
        throw new Error("Connection is paused due to an error:\n" + this._error.message);
      }
    };

    ConnectionPromise.prototype._callbacks = function() {
      if (typeof this._errorCallback === 'function' && this._error !== null && !this._errorHandled) {
        this._errorCallback(this._error);
        this._errorHandled = true;
      }
      if (typeof this._readyCallback === 'function' && this._connection !== null && !this._readyHandled) {
        this._readyCallback();
        return this._readyHandled = true;
      }
    };

    ConnectionPromise.prototype._schedule = function() {
      var next,
        _this = this;
      if (this._queue[0]) {
        next = this._queue.shift();
        return process.nextTick(function() {
          return _this._run(next);
        });
      }
    };

    ConnectionPromise.prototype._run = function(stmt) {
      var next, resolver,
        _this = this;
      if (this._released) {
        return;
      }
      resolver = stmt[2];
      if (!resolver instanceof events.EventEmitter) {
        resolver = {
          emit: function() {
            return this;
          }
        };
      }
      this._pendingStmt = stmt;
      if (!stmt[1]) {
        stmt[1] = void 0;
      }
      next = function() {
        if (_this._pendingStmt === stmt) {
          _this._pendingStmt = null;
          if (!_this._error) {
            _this._schedule();
          }
          return _this._callbacks();
        }
      };
      return this._wrapper.execute(this._connection, stmt[0], stmt[1], function(row) {
        next();
        return resolver.emit('row', row);
      }, function() {
        next();
        return resolver.emit('end');
      }, function(err) {
        var msg;
        if (err && _this._error === null) {
          msg = "Error happened when executing statement.\n Statement: '" + stmt[0] + "'\n Arguments: '" + (inspect(stmt[1])) + "'\n Cause: " + err.message;
          _this._error = new Error(msg);
        }
        next();
        return resolver.emit('error', _this._error);
      });
    };

    ConnectionPromise.prototype._runIfNext = function(stmt) {
      var shouldRun;
      shouldRun = this._pendingStmt === null && this._connection !== null && this._queue[0] === stmt;
      if (shouldRun) {
        return this._run(this._queue.shift());
      }
    };

    ConnectionPromise.prototype._clearError = function() {
      this._error = null;
      return this._errorHandled = false;
    };

    /**
    * Schedule a SQL statement for execution.
    *
    * @param {String} sql Statement to be scheduled.
    * @param {Array} params Parameters that will be safely interpolated on the
    * SQL string.
    * @return {ResultPromise} Promise to the result of executing the statement.
    *
    */


    ConnectionPromise.prototype.exec = function(sql, params) {
      var resolver, stmt;
      if (typeof sql !== 'string') {
        throw new Error('Pass SQL string as first argument');
      }
      this._checkState();
      resolver = new events.EventEmitter();
      stmt = [sql, params, resolver];
      this._queue.push(stmt);
      this._runIfNext(stmt);
      return new ResultPromise(resolver);
    };

    /**
    * Resumes the execution of pending statements
    *
    */


    ConnectionPromise.prototype.resume = function(reset) {
      if (!this._error) {
        throw new Error('Connection is not currently paused');
      }
      this._clearError();
      if (reset) {
        return this._queue = [];
      } else {
        return this._schedule();
      }
    };

    /**
    * If the connection came from a pool it is returned, else the connection is
    * closed.
    *
    */


    ConnectionPromise.prototype.release = function() {
      if (!this._released) {
        this._released = true;
        return this._releaser(this._connection);
      }
    };

    /**
    * Closes the connection
    *
    */


    ConnectionPromise.prototype.close = function() {
      if (!this._released) {
        this._released = true;
        return this._closer(this._connection);
      }
    };

    /**
    * Starts a transaction with the specified isolation level. 
    * Acceptable values(The DBMS may not support all):
    * 0 - Read uncommited
    * 1 - Read commited (default)
    * 2 - Repeatable read
    * 3 - Serializable
    *
    * @param {Number} isolationLevel Isolation level.
    *
    */


    ConnectionPromise.prototype.begin = function(isolation) {
      var res, rv, s, sql, _i, _len;
      this.inTransaction = true;
      sql = this._wrapper.begin(isolation);
      rv = null;
      if (Array.isArray(sql)) {
        for (_i = 0, _len = sql.length; _i < _len; _i++) {
          s = sql[_i];
          res = this.exec(s);
          if (rv === null) {
            rv = res;
          }
        }
      } else {
        rv = this.exec(sql);
      }
      return rv;
    };

    /**
    * Commits the current pending transaction. If no transaction is currently
    * pending, an error is thrown.
    *
    */


    ConnectionPromise.prototype.commit = function() {
      this.inTransaction = false;
      return this.exec(this._wrapper.commit());
    };

    /**
    * Creates a savepoint that can be reverted to.
    *
    * @param {String} savepoint Savepoint identifier that can be passed to
    * 'rollback'.
    *
    */


    ConnectionPromise.prototype.save = function(savepoint) {
      return this.exec(this._wrapper.save(savepoint));
    };

    /**
    * Reverts the changes made by the currently pending transaction to the
    * specified savepoint. If no savepoint is specified, the rollback will
    * revert all changes since 'begin' was last called.
    *
    * @param {String} savepoint Savepoint to revert.
    *
    */


    ConnectionPromise.prototype.rollback = function(savepoint) {
      if (!savepoint) {
        this.inTransaction = false;
      }
      if (this._error) {
        this._clearError();
        this._queue = [];
      }
      return this.exec(this._wrapper.rollback(savepoint));
    };

    /**
    * Sets a handler to be executed when the connection is ready.
    *
    * @param {Function} cb Callback to be invoked when the connection is ready.
    *
    */


    ConnectionPromise.prototype.ready = function(cb) {
      this._readyCallback = cb;
      return this._callbacks();
    };

    /**
    * Sets a handler to be executed if a error happens during connection or 
    * execution of a statement. If there's a pending error when the handler
    * is set, it will be executed imediately. When an error occurs, the 
    * connection can no longer be used. 
    *
    * @param {Function} cb Callback to be invoked if a error occurs.
    *
    */


    ConnectionPromise.prototype.error = function(cb) {
      this._errorCallback = cb;
      return this._callbacks();
    };

    return ConnectionPromise;

  })();

  /**
  * Manages/limits connections to the database.
  *
  */


  ConnectionPool = (function() {

    function ConnectionPool(_wrapper, connectionString, max, timeout) {
      var _this = this;
      this._wrapper = _wrapper;
      if (typeof max !== 'number') {
        max = 10;
      }
      if (typeof timeout !== 'number') {
        timeout = 30000;
      }
      this._inner = genericPool.Pool({
        create: function(cb) {
          return _wrapper.connect(connectionString, cb);
        },
        destroy: function(connection) {
          return _wrapper.close(connection);
        },
        max: max,
        idleTimeoutMillis: timeout
      });
    }

    /**
    * Starts resolving a connection to the database and returns a promise to it.
    *
    * @return {ConnectionPromise} Object that can be used to interact with the
    * database.
    *
    */


    ConnectionPool.prototype.get = function() {
      var destroyed, released, resolver, rv,
        _this = this;
      destroyed = false;
      released = false;
      resolver = new events.EventEmitter();
      rv = new ConnectionPromise(this._wrapper, resolver, function(connection) {
        if (connection === null) {
          return released = true;
        } else {
          return _this._inner.release(connection);
        }
      }, function(connection) {
        if (connection === null) {
          return destroyed = true;
        } else {
          return _this._inner.destroy(connection);
        }
      });
      this._inner.acquire(function(err, connection) {
        if (destroyed && connection) {
          return _this._inner.destroy(connection);
        } else if (released && connection) {
          return _this._inner.release(connection);
        } else {
          return resolver.emit('resolve', err, connection);
        }
      });
      return rv;
    };

    return ConnectionPool;

  })();

  /**
  * Represents the future result of a SQL statement. This object will be 
  * 'consumed' when a callback passed to any of its result-consuming methods, so
  * it can only be used to consume results once.
  *
  * @param resolver EventEmitter that will emit a 'resolve' event when
  * the result is ready.
  *
  */


  ResultPromise = (function() {

    function ResultPromise(resolver) {
      var _this = this;
      this._buffer = [];
      this._rowIdx = 0;
      this._error = null;
      this._callback = null;
      this._then = null;
      this._finished = false;
      this._done = false;
      resolver.on('row', function(row) {
        if (_this._buffer === null) {
          return;
        }
        _this._buffer.push(row);
        return _this._flush();
      });
      resolver.on('end', function() {
        _this._finished = true;
        return _this._flush();
      });
      resolver.on('error', function(err) {
        _this._error = err;
        _this._finished = true;
        return _this._flush();
      });
    }

    ResultPromise.prototype._flush = function() {
      if (typeof this._callback === 'function' && !this._error) {
        this._callback();
      }
      if (typeof this._then === 'function' && this._finished) {
        return this._then();
      }
    };

    ResultPromise.prototype._consume = function(cb) {
      if (typeof this._callback === 'function') {
        throw new Error('Result callback already set');
      }
      return this._callback = cb;
    };

    /**
    * Waits for all rows and pass them to the callback.
    *
    * @param {Function} cb Callback used to return all rows.
    *
    */


    ResultPromise.prototype.all = function(cb) {
      var _this = this;
      this._consume(function() {
        if (_this._finished && _this._buffer !== null) {
          cb(_this._buffer);
          return _this._buffer = null;
        }
      });
      this._flush();
      return this;
    };

    /**
    * Iterates through each result row as soon as possible, calling the
    * callback with the row/index as first/second arguments
    *
    * @param {Function} cb Callback used to return each row.
    *
    */


    ResultPromise.prototype.each = function(cb) {
      var _this = this;
      this._consume(function() {
        var _results;
        if (_this._buffer !== null) {
          _results = [];
          while (_this._buffer.length) {
            cb(_this._buffer.shift(), _this._rowIdx);
            _results.push(_this._rowIdx++);
          }
          return _results;
        }
      });
      this._flush();
      return this;
    };

    /**
    * Gets the first row in the result and invokes the callback with it.
    *
    * @param {Function} cb Callback used to return the first row.
    *
    */


    ResultPromise.prototype.first = function(cb) {
      var _this = this;
      this._consume(function() {
        if (_this._buffer !== null && _this._buffer.length) {
          cb(_this._buffer[0]);
          return _this._buffer = null;
        } else if (_this._finished && _this._error !== null) {
          return cb(null);
        }
      });
      this._flush();
      return this;
    };

    /**
    * Gets a single scalar value from the first row in the result and invokes 
    * the callback with it. Only call this when the result contains only one 
    * column.
    *
    * @param {Function} cb Callback used to return the scalar.
    *
    */


    ResultPromise.prototype.scalar = function(cb) {
      return this.first(function(firstRow) {
        var column, _results;
        _results = [];
        for (column in firstRow) {
          cb(firstRow[column]);
          break;
        }
        return _results;
      });
    };

    /**
    * Executes a handler when the rows are fully processed
    *
    * @param {Function} cb Handler to execute.
    *
    */


    ResultPromise.prototype.then = function(cb) {
      var _this = this;
      if (this._then !== null) {
        throw new Error("'then' callback already set");
      }
      this._then = function() {
        if (!_this._done) {
          _this._done = true;
          return cb(_this._error);
        }
      };
      this._flush();
      return this;
    };

    return ResultPromise;

  })();

  drivers = {};

  exports.register = function(name, wrapper) {
    return drivers[name] = new Driver(wrapper);
  };

  exports.getDriver = function(name) {
    return drivers[name];
  };

  require('./sqlite');

  require('./postgres');

  require('./mysql');

}).call(this);
